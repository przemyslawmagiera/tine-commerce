\chapter{Implementacja systemu}
\thispagestyle{chapterBeginStyle}

\section{Opis technologii}
W projektcie użyto wielu technologi oraz frameworków. Wszystkie oparte są o język Java, dokumentację można znaleźć w \cite{Java-doc}. Interfejs użytkownika zaprojektowano przy użyciu szablonów opartych o projekt Start Bootstrap, którego opis można znaleźć na stronie \cite{sb}. 

\subsection{Spring Framework/Spring Boot}
Główną technologią jest framework Spring. Ułatwia pisanie aplikacji w Javie, w szczególności webowych, ze względu na dużą elastyczność i wzorzec projektowy Model-View-Controller, singleton oraz spełnia zasadę \textit{Inversion of Control}. Aplikacja jest oparta o platformę Spring Boot. Jest to nakładka na framework Spring, który przy obecnych standardach stał się skomplikowany w konfiguracji. Spring Boot zapewnia autokonfigurację wielu komponentów systemu, łatwe dodawanie modułów Springowych (np. security lub web). Co najważniejsze posiada wbudowany kontener na aplikację internetową, przez co nie ma potrzeby konfigurowania osobnego kontenera (np. Tomcat) i umieszczania tam aplikacji. Znacznie przyśpiesza to dewelopment. Więcej informacji najduje się w dokumentacji \cite{springb-docs} oraz w książce \cite{springbook}.

\subsection{Hibernate/JPA 2.1} 
Java Persistence API jest interfejsem służącym do komunikacji aplikacji z bazą danych. Jego implementacją jest framework Hibernate. Korzystanie z tych standardów ułatwia komunikację z bazą danych i zapewnia wiele przydatnych funkcjonalności. Między innymi zapewnia również obsługę transakcji. W połączeniu ze Spring Data to potężne narzędzie, a jednocześnie jest proste w użytku. Więcej informacji o frameworku Hibernate i JPA w książce \cite{JPA-hib}. 
\subsection{Spring Data}
Spring Data ułatwia konfigurację połączeń między bazą danych, a serwerem. Do tego zapewnia automatyczne generowanie prostych kwerend bazodanowych, korzystając z zasady \textit{query by convention}\footnote{query by convention - sposób generowania kwerend bazodanowych na podstawie nazw metod w interfejsach}. Jest to sposób pisania nazw metod w interfejsach, które framework jest w stanie zaimplementować. Całość powoduje odejście tradycyjnej warstwy DataAccessObject. Framework pozwala na samodzielne implementowanie trudniejszych kwerend, w spersonalizowany sposób. 

\subsection{Apache Solr} 
Oparta na silniku Lucene i uruchomiona na osobnym serwerze wyszukiwarka zapewnia odseparowanie najbardziej obciążonej części sklepu. Dzięki Solrowi w implementowanym frameworku jest obecna bardzo szybka wyszukiwarka z możliwością wyszukiwania pełnotekstowego, filtrowania, sortowania i zawężania wyników względem różnych pól produktu. Książka \cite{solrbook} i dokumentacja \cite{Solr-doc} opisują działanie i możliwości Solra. Do integracji serwera Apache Solr z implementowanym frameworkiem użyto biblioteki SolrJ \cite{solrJ}.

\section{Omówienie kodów źródłowych}
Projekt składa się z 3986 linii kodu w języku Java, dlatego aby zachować zwięzłość i zrozumiałość w ramach omówienia kodów źródłowych zostanie przedstawiona tylko jedna funkcjonalność odnosząca się do konkretnych przypadków użycia zdefiniowanych w sekcji \textbf{Przypadki użycia} rozdziału \textbf{Projekt systemu}. 

Na rysunku \ref{useCaseProgrammer} znajduje się use-case: \textit{Zarządzanie encjami}. Związany jest przypadek z diagramu \ref{dynEntFormUC} \textit{Wyświetlenie i manipulacja relacjami encji}.  Te dwa przypadki wiążą się z konstrukcją dynamicznego formularza edycji dla danej encji. Dla lepszego zrozumienia warto przypomnieć diagramy związane z implementacją tej funkcjonalności. Na rysunku \ref{konsFormEnc} przedstawiono diagram aktywności, zaś rysunek \ref{klasy_formularz_encyjny} przedstawia klasy użyte do implementacji.

Dla przykładu działania kodu źródłowego zostanie przeanalizowana budowa formularza dla encji \texttt{Product}. Kod 

\begin{small}
\begin{lstlisting}[language=Java, frame=lines, numberstyle=\tiny, stepnumber=5, caption=Wyświetlenie formularza encyjnego: \texttt{DynamicEntityController.java}\label{ws}., firstnumber=1]


\end{lstlisting} 
\end{small}

{\color{dgray}
Kod źródłowy~\ref{req} przedstawia procedurę przetwarzającą żądanie. Hasz utrwalany \verb|%granulacja| wykorzystywany jest do komunikacji międzyprocesowej.
}https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/

\begin{small}
\begin{lstlisting}[language=perl, frame=lines, caption=Przetwarzanie żądania - procedura \texttt{process\_req()}\label{req}., firstnumber=86]
sub process_req(){	
  my($r) = @_;
  $wyn = "";
  if ($r=~/get/i) {
	@reqest = split(" ",$r);
	$zad = $reqest[0];
	$ts1 = $reqest[1];
	$ts2 = $reqest[2];
	@date1 = split(/\D/,$ts1);
	@date2 = split(/\D/,$ts2);
	print "odebralem: $r"; 
	$wyn = $wyn."zadanie: $zad\n";
	$wyn = $wyn."czas_od: "."$date1[0]"."-"."$date1[1]"."-"."$date1[2]"."_"."$date1[3]".":"."$date1[4]".":"."$date1[5]"."\n";
	$wyn = $wyn."czas_do: "."$date2[0]"."-"."$date2[1]"."-"."$date2[2]"."_"."$date2[3]".":"."$date2[4]".":"."$date2[5]"."\n";		
	$wyn = $wyn.&sym_sens($ts1,$ts2);
	return $wyn;
  }
  if ($r=~/set gt/i) {
	@reqest = split(" ",$r);
	$zad = $reqest[0];
	$ts1 = $reqest[1];
	$ts2 = $reqest[2];
	$gt = $reqest[2];
	dbmopen(%granulacja,"granulacja_baza",0644);
	$granulacja{"gt"}=$gt;
	dbmclose(%granulacja);
	$wyn = "\'GT\' zmienione na: $gt";
  }		
}	
\end{lstlisting} 
\end{small}
